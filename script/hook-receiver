#!/usr/bin/env ruby
# frozen_string_literal: true

require "socket"
require 'pp'
require "digest"
require "pathname"
require "logger"

# What's a little monkey patching among friends?
# From https://bugs.ruby-lang.org/issues/12573
def Process.exists?(pid)
  Process.kill(0, pid.to_i)
  true
rescue Errno::ESRCH # No such process
  false
rescue Errno::EPERM # The process exists, but you don't have permission to send the signal to it.
  true
end

root_path = Pathname.new(__FILE__).dirname.dirname
LOG_DIR = root_path.join("log")
HOOK_PROCESSORS_DIR = root_path.join("hook_processors")

log_path = LOG_DIR.join("hooks.log")
Log = Logger.new(log_path)

PID_FILE = root_path.join(".hook_receiver.pid")


if PID_FILE.exist?
  $log.error "PID file exists for hook receiver, is it already running? If not, delete .hook_receiver.pid and try again."
  exit 1
end

PID_FILE.write("#{Process.pid}")
at_exit do
  PID_FILE.unlink if PID_FILE.exist?
end

def read_chunk(connection)
  chunk = []
  loop do
    line = connection.gets
    break if line == "\r\n"

    chunk << line
  rescue EOFError
    break
  end
  chunk
end

def receive_payload(connection)
  payload = ""
  loop do
    payload += connection.read_nonblock(1024 * 16)
  rescue Errno::EAGAIN, EOFError
    break
  end
  payload
end

def validate_hook_signature?(headers, _payload)
  header_signature = headers.find { |h| h.include?("X-Hub-Signature") }&.split(": ")&.last
  return false unless header_signature
  signature = "sha1=#{OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new('sha1'), HOOK_SECRET, payload_body)}"
  header_signature == signature
end

def dispatch_receiver(headers, payload)
  event = headers.find { |h| h.include?("X-GitHub-Event") }&.split(": ")&.last
  return unless event
  action = payload["action"]
  executable = HOOK_PROCESSORS_DIR.join("#{event}-#{action}")
  return unless executable.exist?
  processor_log = LOG_DIR.join("#{event}-#{action}.log")
  
  log "Dispatching #{executable}"
  pid = Kernel.spawn("echo #{payload} | #{executable}", [:out, :err] => processor_log)
  Thread.new(pid, processor_log, executable) do |pid|
    sleep 30

    if Process.exists?(pid)
      File.write(procesord_log, "Terminating due to timeout", mode: "a")
      log "Sending kill to #{executable} PID: #{pid}"
      Process.kill(pid)
    end
  end
  #Open3.popen2e([env,] cmd... [, opts]) {|stdin, stdout_and_stderr, wait_thr|
  #Open3.popen2e(executable.to_s) {|stdin, stdout_and_stderr, wait_thr|
   # pid = wait_thr.pid # pid of the started process.
    #exit_status = wait_thr.value # Process::Status object returned.
  #}
end

def log(msg)
  Log.info(msg)
end

log "Waiting for a webhook secret to be configured"
secret = nil

until secret do
  secret = `apptokit manifest show | jq .webhook_secret`.chomp
  secret = nil if secret == "null"
  sleep 5 unless secret
end
HOOK_SECRET = secret.gsub('"', '')

server = TCPServer.new(8077)
server.setsockopt(Socket::IPPROTO_TCP, Socket::TCP_NODELAY, 1)
log "listening for webhooks on port 8077"

begin
  Socket.accept_loop(server) do |connection|
    headers = read_chunk(connection)

    if headers.first == "POST / HTTP/1.1\r\n"
      payload = receive_payload(connection)

      valid_signature = validate_hook_signature(headers, payload)

      hash = begin
        JSON.parse(payload)
      rescue StandardError
        log "Not valid JSON"
      end

      log "Received hook:"
      log headers.join
      log "  -- Webhook signature validated --" if valid_signature
      log "received payload:\n"
      log hash.pretty_inspect
    else
      log headers.join("")
      log "this doesn't look like a webhook, skipping"
    end

    connection.write "HTTP/1.1 204 No Content\r\n"
    connection.close
  end
rescue Interrupt
  log "bye!"
  exit 0
end