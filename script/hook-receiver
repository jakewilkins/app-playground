#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/inline"

gemfile do
  source "https://rubygems.org"
  gem "sinatra"
end

require "sinatra"

require 'pp'
require "digest"
require "pathname"
require "logger"
require "json"
require "openssl"

# What's a little monkey patching among friends?
# From https://bugs.ruby-lang.org/issues/12573
def Process.exists?(pid)
  Process.kill(0, pid.to_i)
  true
rescue Errno::ESRCH # No such process
  false
rescue Errno::EPERM # The process exists, but you don't have permission to send the signal to it.
  true
end

root_path = Pathname.new(__FILE__).dirname.dirname
HOOK_PROCESSORS_DIR = root_path.join("hook_processors")
PID_FILE = root_path.join(".hook_receiver.pid")
LOG_DIR = root_path.join("log")
LOG_PATH = LOG_DIR.join("hooks.log")

if %w(stop restart).include?(ARGV[0]) && PID_FILE.exist?
  pid = PID_FILE.read
  Process.kill("INT", pid.to_i)
  exit 0 if ARGV[0] == "stop"
end

Process.daemon(true)
Log = Logger.new(LOG_PATH)

if ENV["DEBUG"]
  Log.level = Logger::DEBUG
else
  Log.level = Logger::INFO
end

def log(msg, level: :debug)
  Log.send(level, msg)
end

PROCESSOR_LOGS = Hash.new do |hash, key|
  hash[key] = File.open(LOG_DIR.join("#{key}.log"), "a+")
end

if PID_FILE.exist?
  log "PID file exists for hook receiver, is it already running? If not, delete .hook_receiver.pid and try again.", level: :error
  exit 1
end

PID_FILE.write("#{Process.pid}")
at_exit do
  PID_FILE.unlink if PID_FILE.exist?
end

def find_header_value(name, headers)
  headers[name] || headers[name.downcase] || headers["HTTP_#{name.upcase}".gsub('-', '_')]
end

def validate_hook_signature(headers, payload_body)
  header_signature = find_header_value("X-Hub-Signature", headers)
  signature = "sha1=#{OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new('sha1'), HOOK_SECRET, payload_body.to_json)}"
  log "Comparing header: #{header_signature.inspect} to generated: #{signature.inspect}"
  return false unless header_signature
  header_signature == signature
end

def dispatch_processor(headers, payload)
  event = find_header_value("X-GitHub-Event", headers)
  action = payload["action"]
  executable = HOOK_PROCESSORS_DIR.join("#{event}-#{action}")

  executable_available = executable.exist?
  if executable_available
    log "Dispatching #{executable}", level: :info
  else
    log "No processor configured for #{event.inspect}-#{action.inspect}", level: :info
    return
  end

  processor_log = PROCESSOR_LOGS["#{event}-#{action}"]
  pid = Kernel.spawn("echo '#{payload.to_json}' | #{executable}", [:out, :err] => processor_log)

  # Setup a timeout to clearout hung processes
  Thread.new(pid, processor_log, executable) do |pid, processor_log, executable|
    sleep 30

    if Process.exists?(pid)
      processor_log.puts("Terminating due to timeout")
      processor_log.flush
      Logger.new(LOG_PATH).debug "Sending kill to #{executable} PID: #{pid}"
      Process.kill("INT", pid)
    end
  end
end

log "Waiting for a webhook secret to be configured", level: :info
secret = nil
apptokit = ""
until !apptokit.empty? do
  apptokit = `which apptokit 2>/dev/null`.chomp
  sleep 0.5
end

until secret do
  secret = `apptokit manifest show | jq .webhook_secret`.chomp
  secret = nil if secret == "null" || secret == ""
  sleep 5 unless secret
end
HOOK_SECRET = secret.gsub('"', '')

log "listening for webhooks on port 8077", level: :info

post("/hooks") do
  log "Receiving hook"
  request.body.rewind  # in case someone already read it
  body = request.body.read
  log "Received body: #{body}"
  log "Received headers: #{request.env}"

  hash = begin
    JSON.parse body
  rescue StandardError => boom
    log "Not valid JSON: #{boom.class} - #{boom.message}"
    halt([204, {}, []])
  end

  unless validate_hook_signature(request.env, hash)
    log "Invalid webhook signature, skipping processing", level: :info
    halt(204, {}, [])
  end

  dispatch_processor(request.env, hash)

  [204, {}, []]
end

begin
  Sinatra::Application.run!(port: 8077)
rescue Interrupt
  log "bye!", level: :info
  exit 0
end
